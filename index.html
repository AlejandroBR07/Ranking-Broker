<!DOCTYPE html>
<html lang="pt-BR" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Command Center v10.2: Apex | Aldeia</title>
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <!-- Chart.js CDN for charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        /* Custom CSS Variables for Theming */
        :root {
            --bg-color: #0A0A0F;
            --panel-bg: rgba(15, 18, 32, 0.5);
            --border-color: rgba(56, 73, 117, 0.3);
            --glow-color: #38BDF8; /* A vibrant blue for highlights */
            --text-primary: #E5E7EB;
            --text-secondary: #9CA3AF;
        }

        /* Base body styling */
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: var(--bg-color);
            overflow: hidden; /* Prevent scrollbars from animated background */
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh; /* Full viewport height */
        }

        /* Animated grid background */
        #animated-bg {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: -1; /* Behind other content */
            background-image: 
                linear-gradient(rgba(56, 189, 248, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(56, 189, 248, 0.1) 1px, transparent 1px);
            background-size: 60px 60px;
            animation: grid-pan 80s linear infinite; /* Slow, continuous pan */
        }

        /* Keyframe animation for the grid background */
        @keyframes grid-pan {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        /* Main command center panel styling */
        #command-center {
            width: 100%;
            max-width: 1600px; /* Increased width for better layout of 3 columns */
            height: 90vh;
            max-height: 900px;
            background-color: var(--panel-bg);
            backdrop-filter: blur(24px); /* Frosted glass effect */
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid var(--border-color);
            border-radius: 2rem; /* Rounded corners for the main panel */
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 80px rgba(0, 0, 0, 0.6); /* Soft shadow */
            padding: 2rem;
            opacity: 0;
            transform: scale(0.95);
            animation: fadeInPanel 1s ease-out forwards; /* Fade in animation on load */
        }

        /* Keyframe animation for the main panel fade in */
        @keyframes fadeInPanel {
            to { opacity: 1; transform: scale(1); }
        }

        /* Styling for content slides */
        .view-slide {
            position: absolute; /* Position slides on top of each other */
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.7s ease-in-out, transform 0.7s ease-in-out;
            transform: translateY(20px); /* Slight vertical slide effect */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem 0;
        }
        .view-slide.active { 
            opacity: 1; 
            visibility: visible; 
            transform: translateY(0); 
        }

        /* Keyframe animation for child elements within active slides */
        @keyframes fadeInChild {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .view-slide.active .fade-in-child { 
            animation: fadeInChild 0.6s ease-out forwards; 
        }
        
        /* Progress bar styling */
        #progress-bar {
            height: 100%;
            background: var(--glow-color);
            transition: width 0.1s linear; /* Smooth width transition */
            box-shadow: 0 0 10px var(--glow-color);
            border-radius: 2px;
        }
        
        /* Styling for filter and ranking buttons */
        .filter-btn, .ranking-tab {
            color: var(--text-secondary); 
            background-color: rgba(30, 41, 59, 0.6);
            border: 1px solid transparent;
            transition: all 0.3s ease;
        }
        .filter-btn:hover, .ranking-tab:hover {
            background-color: rgba(55, 65, 81, 0.8);
            color: var(--text-primary);
        }
        .filter-btn-active {
            background-color: var(--glow-color);
            color: #030712 !important; /* Dark text on active button */
            font-weight: 600;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
        }

        /* Podium styling for top 3 in general ranking */
        .podium-1 .avatar-ring { border-color: #FFD700; } /* Gold */
        .podium-2 .avatar-ring { border-color: #C0C0C0; } /* Silver */
        .podium-3 .avatar-ring { border-color: #CD7F32; } /* Bronze */
        
        /* Rank change indicators */
        .rank-up { color: #22c55e; } /* Green */
        .rank-down { color: #ef4444; } /* Red */
        .rank-stable { color: #6b7280; } /* Gray */
        
        /* Navigation dots styling */
        .nav-dots {
            position: absolute;
            bottom: 1.5rem; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 0.75rem;
        }
        .nav-dot {
            width: 10px; height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .nav-dot:hover { background-color: rgba(255, 255, 255, 0.4); }
        .nav-dot.active { 
            background-color: var(--glow-color); 
            transform: scale(1.2); 
            box-shadow: 0 0 8px var(--glow-color); 
        }
        
        /* Animation for highlighting changes in ranking */
        .highlight-change { animation: highlight 1.5s ease-out; }
        @keyframes highlight {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(56, 189, 248, 0.2); }
        }

        /* Custom scrollbar styles for ranking list */
        .ranking-list::-webkit-scrollbar { width: 4px; }
        .ranking-list::-webkit-scrollbar-track { background: transparent; }
        .ranking-list::-webkit-scrollbar-thumb { 
            background-color: rgba(56, 189, 248, 0.5); 
            border-radius: 20px; 
        }

        /* Navigation arrows styling */
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0; /* Hidden by default, appears on hover of command-center */
            z-index: 20;
            color: white;
        }
        #command-center:hover .nav-arrow { opacity: 1; } /* Show arrows on hover */
        .nav-arrow:hover { 
            background-color: rgba(55, 65, 81, 0.8); 
            border-color: var(--glow-color); 
        }
        #prev-slide { left: 0.5rem; }
        #next-slide { right: 0.5rem; }
    </style>
</head>
<body>
    <!-- Animated background element -->
    <div id="animated-bg"></div>

    <!-- Main Command Center Container -->
    <div id="command-center">
        <!-- Main Content Area with Slides -->
        <main id="slides-container" class="flex-grow relative">
            <!-- SLIDE 1: General Metrics (Depósitos, Ativações, Indicações) -->
            <div id="view-general-metrics" class="view-slide active">
                <div class="w-full flex flex-col items-center">
                    <header class="flex-shrink-0 mb-6 text-center">
                        <h1 class="text-3xl font-bold text-white fade-in-child">Métricas Gerais</h1>
                    </header>
                    <div id="general-metrics-content" class="w-full max-w-5xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-8 items-start">
                        <!-- General metrics cards will be rendered here by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- SLIDE 2: Leaderboard -->
            <div id="view-leaderboard" class="view-slide">
                <div class="w-full h-full flex flex-col items-center">
                    <header class="flex-shrink-0 mb-4 text-center">
                        <h1 class="text-3xl font-bold text-white fade-in-child">Ranking Geral de Brokers</h1>
                    </header>
                    <!-- Leaderboard content now uses 3 columns to show multiple rankings -->
                    <div id="leaderboard-content" class="flex-grow w-full max-w-7xl grid grid-cols-1 lg:grid-cols-3 gap-6 min-h-0">
                        <!-- Leaderboard lists will be rendered here by JavaScript -->
                    </div>
                </div>
            </div>
            
            <!-- SLIDE 3: Financial Chart -->
            <div id="view-chart" class="view-slide">
                <div class="w-full h-full flex flex-col items-center">
                    <header class="flex-shrink-0 mb-4 text-center">
                        <h1 class="text-3xl font-bold text-white fade-in-child">Análise Gráfica</h1>
                        <p id="chart-period-title" class="text-gray-400 fade-in-child" style="animation-delay: 100ms;"></p>
                    </header>
                    <div id="chart-content" class="flex-grow relative fade-in-child w-full max-w-5xl h-[400px]" style="animation-delay: 200ms;">
                        <canvas id="mainChart"></canvas>
                    </div>
                </div>
            </div>
        </main>

        <!-- Fixed Footer with Controls -->
        <footer class="flex-shrink-0">
            <div id="filter-container" class="mb-4 flex flex-wrap items-center justify-center gap-2">
                <!-- Period filters (Geral, Hoje, Esta Semana, Months) will be inserted here by JavaScript -->
            </div>
            <div id="nav-dots-container" class="nav-dots"></div>
            <div class="absolute bottom-4 right-4 text-xs text-gray-500 flex items-center gap-3">
                <span id="countdown-timer"></span>
                <button id="refresh-btn" title="Atualizar Agora" class="p-1 rounded-full text-gray-400 hover:bg-white/10 hover:text-white transition duration-300">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                </button>
            </div>
            <div id="progress-bar-container" class="w-full h-1 bg-white/5 absolute bottom-0 left-0 rounded-b-3xl overflow-hidden">
                <div id="progress-bar" style="width: 0%;"></div>
            </div>
        </footer>

        <!-- Navigation Arrows -->
        <button id="prev-slide" class="nav-arrow">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
        </button>
        <button id="next-slide" class="nav-arrow">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </button>

        <!-- Loader overlay -->
        <div id="loader" class="absolute inset-0 flex items-center justify-center bg-black/80 rounded-3xl z-30">
            <p class="text-gray-300 text-lg">Iniciando Command Center...</p>
        </div>
    </div>

    <script>
    (() => {
        // --- CONFIGURAÇÕES GLOBAIS ---
        // URLs dos seus Webhooks no n8n. ATUALIZE ESTES LINKS COM OS SEUS!
        const DEPOSIT_WEBHOOK_URL = 'https://alejandroabc.app.n8n.cloud/webhook/42f1372b-15ea-4f55-9b71-0e8737ab2311';
        const INDICATIONS_WEBHOOK_URL = 'https://alejandroabc.app.n8n.cloud/webhook/7b5794a9-b105-47b5-85ed-004e54e05f7a'; // URL corrigida
        
        // Intervalo de atualização dos dados (em milissegundos). 30 minutos = 1800 * 1000 ms
        const DATA_REFRESH_INTERVAL = 1800 * 1000; 
        
        // Intervalo de rotação automática dos slides (em milissegundos)
        const VIEW_ROTATION_INTERVAL = 15 * 1000; // 15 segundos

        // Mapeamento de nomes de brokers para nomes curtos ou padronizados.
        // Mantenha apenas se você tiver variações de nomes de brokers no seu Google Sheet.
        const BROKER_MAP = {
            'Vinicius Cezar': 'Vinicius Cezar',
            'Luiz Henrique': 'Luiz Henrique',
            'Brayan França': 'Brayan França',
            'ALEJANDRO': 'ALEJANDRO', // Adicionado para consistência
            'BIANCA': 'BIANCA', // Adicionado para consistência
            'LUIZ': 'LUIZ', // Adicionado para consistência
            'BRAYAN': 'BRAYAN', // Adicionado para consistência
            // Adicione outros mapeamentos se necessário
        };

        // --- ESTADO DA APLICAÇÃO ---
        let rawDepositData = []; // Armazena os dados brutos de depósitos
        let rawIndicationsData = []; // Armazena os dados brutos de indicações
        let mainChartInstance = null; // Instância do Chart.js
        let dataRefreshIntervalId, countdownIntervalId, rotationTimeoutId, animationFrameId;
        let rotationStartTime, rotationRemainingTime = VIEW_ROTATION_INTERVAL;
        let currentPeriod = 'all'; // Período de filtro atual: 'all', 'today', 'this_week', ou 'MM_YYYY'
        let currentViewIndex = 0; // Índice do slide atual
        let previousRankings = {}; // Armazena os rankings anteriores para calcular mudança de posição
        let isPaused = false; // Estado de pausa da rotação automática
        
        // Array com os IDs dos slides para navegação
        const views = ['view-general-metrics', 'view-leaderboard', 'view-chart'];

        // Referências aos elementos DOM para fácil acesso
        const DOM = {
            commandCenter: document.getElementById('command-center'),
            loader: document.getElementById('loader'),
            slides: views.map(id => document.getElementById(id)),
            progressBar: document.getElementById('progress-bar'),
            filterContainer: document.getElementById('filter-container'),
            dotsContainer: document.getElementById('nav-dots-container'),
            chartPeriodTitle: document.getElementById('chart-period-title'),
            generalMetricsContent: document.getElementById('general-metrics-content'), 
            leaderboardContent: document.getElementById('leaderboard-content'),
            countdownTimer: document.getElementById('countdown-timer'),
            refreshBtn: document.getElementById('refresh-btn'),
            prevBtn: document.getElementById('prev-slide'),
            nextBtn: document.getElementById('next-slide'),
        };
        
        // --- FUNÇÕES AUXILIARES ---

        // Função para obter valor de um item, tentando múltiplas chaves (para flexibilidade com nomes de colunas)
        const getValue = (item, ...keys) => {
            for (const key of keys) {
                if (item?.[key] != null) return item[key];
            }
            return '';
        };

        // Converte valor para número float, tratando vírgulas e pontos
        const parseCurrency = (value) => { 
            if (typeof value === 'number') return value; 
            if (typeof value === 'string' && value.trim() !== '') {
                let cleanedValue = value.replace(/[^\d.,-]/g, '');
                if (cleanedValue.includes(',') && cleanedValue.includes('.')) {
                    if (cleanedValue.indexOf(',') < cleanedValue.indexOf('.')) { 
                        cleanedValue = cleanedValue.replace(/\./g, '').replace(',', '.');
                    } else { 
                        cleanedValue = cleanedValue.replace(/,/g, ''); 
                    }
                } else if (cleanedValue.includes(',')) { 
                    cleanedValue = cleanedValue.replace(',', '.');
                }
                return parseFloat(cleanedValue) || 0;
            } 
            return 0; 
        };

        // Formata um número como moeda (USD para consistência, pode mudar para BRL)
        const formatCurrency = (value) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

        // Converte string de data (DD/MM/YYYY) para objeto Date
        const parseDate = (dateStr) => { 
            if (!dateStr || typeof dateStr !== 'string') return null; 
            const parts = dateStr.split('/'); 
            if (parts.length === 3) {
                return new Date(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0])); 
            }
            return null; 
        };

        // Formata um objeto Date para "MMM. YYYY" (ex: "jul. 2025")
        function formatMonthYear(date) {
            if (!date) return null;
            const monthNames = ["jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez"];
            return `${monthNames[date.getMonth()]}. ${date.getFullYear()}`;
        }
        
        // --- LÓGICA DE VISUALIZAÇÃO E SLIDES ---

        // Mostra um slide específico e atualiza os indicadores de navegação
        function showView(index, isManual = false) {
            DOM.slides.forEach((slide, i) => slide.classList.toggle('active', i === index));
            document.querySelectorAll('.nav-dot').forEach((dot, i) => dot.classList.toggle('active', i === index));
            currentViewIndex = index;

            // Se a navegação foi manual, reinicia o timer de rotação
            if (isManual) {
                clearTimeout(rotationTimeoutId);
                cancelAnimationFrame(animationFrameId);
                rotationRemainingTime = VIEW_ROTATION_INTERVAL;
                if (!isPaused) startRotation();
            }
        }

        // Avança para o próximo slide
        function nextView(isManual = false) { 
            showView((currentViewIndex + 1) % views.length, isManual); 
        }

        // Volta para o slide anterior
        function prevView() { 
            showView((currentViewIndex - 1 + views.length) % views.length, true); 
        }
        
        // Atualiza a barra de progresso da rotação automática
        function updateProgressBar() {
            if (isPaused) return;
            const elapsedTime = Date.now() - rotationStartTime;
            const progress = (elapsedTime / rotationRemainingTime) * 100;
            DOM.progressBar.style.width = `${Math.min(progress, 100)}%`;
            animationFrameId = requestAnimationFrame(updateProgressBar);
        }
        
        // Inicia a rotação automática dos slides
        function startRotation() {
            if (isPaused) return;
            rotationStartTime = Date.now();
            cancelAnimationFrame(animationFrameId); 
            animationFrameId = requestAnimationFrame(updateProgressBar); 
            rotationTimeoutId = setTimeout(() => {
                nextView(); 
                rotationRemainingTime = VIEW_ROTATION_INTERVAL; 
                startRotation(); 
            }, rotationRemainingTime);
        }

        // Pausa a rotação automática
        function pauseRotation() { 
            if (isPaused) return; 
            isPaused = true; 
            clearTimeout(rotationTimeoutId); 
            cancelAnimationFrame(animationFrameId); 
            const elapsedTime = Date.now() - rotationStartTime; 
            rotationRemainingTime -= elapsedTime; 
        }

        // Retoma a rotação automática
        function resumeRotation() { 
            if (!isPaused) return; 
            isPaused = false; 
            startRotation(); 
        }
        
        // --- PROCESSAMENTO DE DADOS ---

        // Data mínima para inclusão de dados (Julho de 2025)
        const MIN_DATE = new Date(2025, 6, 1); // Mês 6 é Julho (0-indexed)

        // Filtra e prepara os dados brutos com base no período selecionado e data mínima
        function processData(data, selectedPeriod, isIndicationsData = false) {
            const now = new Date(); 
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()); 
            const startOfWeek = new Date(today); 
            startOfWeek.setDate(today.getDate() - today.getDay() + (today.getDay() === 0 ? -6 : 1));

            return data.map(item => {
                let rawDateString; // String de data no formato DD/MM/YYYY
                let monthYearFormattedString; // String de mês/ano no formato "MMM. YYYY"

                if (isIndicationsData) {
                    // Para indicações, 'col_1' é "DD/MM/YYYY HH:MM:SS"
                    rawDateString = item['col_1'] ? item['col_1'].split(' ')[0] : null; 
                    const parsedDate = parseDate(rawDateString);
                    monthYearFormattedString = parsedDate ? formatMonthYear(parsedDate) : null;
                } else {
                    // Para depósitos, 'col_6' é "DD/MM/YYYY" e 'col_1' é "MMM. YYYY"
                    rawDateString = item['col_6'];
                    monthYearFormattedString = item['col_1']; 
                }

                return { 
                    ...item, 
                    parsedDate: parseDate(rawDateString),
                    monthYearFormatted: monthYearFormattedString 
                };
            })
            .filter(item => {
                // Filtra dados anteriores à data mínima (Julho de 2025)
                if (!item.parsedDate || item.parsedDate < MIN_DATE) return false; 

                const itemDate = new Date(item.parsedDate.getFullYear(), item.parsedDate.getMonth(), item.parsedDate.getDate());
                
                switch (selectedPeriod) {
                    case 'all': return true; 
                    case 'today': return itemDate.getTime() === today.getTime(); 
                    case 'this_week': return itemDate >= startOfWeek && itemDate <= today;
                    default: 
                        if (!item.monthYearFormatted) return false;

                        const [monthAbbr, yearStr] = item.monthYearFormatted.split('. ');
                        const monthMap = {
                            'jan': 0, 'fev': 1, 'mar': 2, 'abr': 3, 'mai': 4, 'jun': 5,
                            'jul': 6, 'ago': 7, 'set': 8, 'out': 9, 'nov': 10, 'dez': 11
                        };
                        const itemMonth = monthMap[monthAbbr.toLowerCase()];
                        const itemYear = parseInt(yearStr);
                        
                        const [selectedMonth, selectedYear] = selectedPeriod.split('_').map(Number);
                        return itemMonth === selectedMonth && itemYear === selectedYear;
                }
            });
        }

        // Calcula os rankings de brokers (por valor, ativação e indicações)
        function calculateRankings(depositData, indicationsData) {
            const summary = {}; 

            // Processa dados de depósitos e ativações
            depositData.forEach(item => { 
                const brokerName = (item['Broker'] || '').trim(); // Normaliza o nome do broker
                if (!brokerName) return; 

                if (!summary[brokerName]) {
                    summary[brokerName] = { 
                        brokerName: brokerName, 
                        totalDeposito: 0, 
                        activationCount: 0,
                        totalIndications: 0, 
                        aldeiaIndications: 0,
                        triboIndications: 0,
                        aldeiaPurchased: 0,
                        triboPurchased: 0
                    }; 
                }
                
                summary[brokerName].totalDeposito += parseCurrency(item['col_5']); 
                
                const ativacaoStatus = item['Ativação']; 
                if (ativacaoStatus === 'Ativação') { 
                    summary[brokerName].activationCount++; 
                }
            });

            // Processa dados de indicações e os associa aos brokers existentes
            indicationsData.forEach(item => {
                const brokerName = (item['BROKER:'] || item['Broker'] || '').replace(':', '').trim(); // Normaliza o nome do broker (removendo colon)
                if (!brokerName) return;

                if (!summary[brokerName]) {
                    summary[brokerName] = { 
                        brokerName: brokerName, 
                        totalDeposito: 0, 
                        activationCount: 0,
                        totalIndications: 0, 
                        aldeiaIndications: 0,
                        triboIndications: 0,
                        aldeiaPurchased: 0,
                        triboPurchased: 0
                    }; 
                }

                const produto = item['Produto']; 
                const comprou = item['Comprou']; 

                if (produto) {
                    summary[brokerName].totalIndications++;
                    if (produto.toLowerCase() === 'aldeia') {
                        summary[brokerName].aldeiaIndications++;
                        if (comprou && comprou.toLowerCase() === 'sim') {
                            summary[brokerName].aldeiaPurchased++;
                        }
                    } else if (produto.toLowerCase() === 'tribo') {
                        summary[brokerName].triboIndications++;
                        if (comprou && comprou.toLowerCase() === 'sim') {
                            summary[brokerName].triboPurchased++;
                        }
                    }
                }
            });

            const allBrokers = Object.values(summary); 
            const valueRanking = [...allBrokers].sort((a, b) => b.totalDeposito - a.totalDeposito); 
            const activationRanking = [...allBrokers].sort((a, b) => b.activationCount - a.activationCount); 
            const indicationsRanking = [...allBrokers].sort((a, b) => b.totalIndications - a.totalIndications);
            
            return { valueRanking, activationRanking, indicationsRanking };
        }

        // Calcula as métricas de indicações (Aldeia e Tribo) - Geral para o período filtrado
        function calculateIndicationsOverall(data) {
            const indicationsSummary = {
                totalIndications: 0,
                aldeia: { total: 0, purchased: 0 },
                tribo: { total: 0, purchased: 0 }
            };

            data.forEach(item => {
                const produto = item['Produto']; 
                const comprou = item['Comprou']; 

                if (produto) {
                    indicationsSummary.totalIndications++;
                    if (produto.toLowerCase() === 'aldeia') {
                        indicationsSummary.aldeia.total++;
                        if (comprou && comprou.toLowerCase() === 'sim') {
                            indicationsSummary.aldeia.purchased++;
                        }
                    } else if (produto.toLowerCase() === 'tribo') {
                        indicationsSummary.tribo.total++;
                        if (comprou && comprou.toLowerCase() === 'sim') {
                            indicationsSummary.tribo.purchased++;
                        }
                    }
                }
            });
            return indicationsSummary;
        }
        
        // --- FUNÇÕES DE RENDERIZAÇÃO ---

        // Renderiza todo o dashboard com base nos dados e filtros atuais
        function renderAll() {
            const periodText = document.querySelector(`.filter-btn[data-period="${currentPeriod}"]`)?.textContent || 'Período Atual';
            
            // Filtra os dados de depósitos e indicações separadamente
            const filteredDepositData = processData(rawDepositData, currentPeriod, false);
            const filteredIndicationsData = processData(rawIndicationsData, currentPeriod, true);

            const rankings = calculateRankings(filteredDepositData, filteredIndicationsData);
            const indicationsOverall = calculateIndicationsOverall(filteredIndicationsData); 

            DOM.chartPeriodTitle.textContent = periodText;
            renderGeneralMetrics(filteredDepositData, indicationsOverall); 
            
            renderLeaderboard(rankings); 
            renderAnalysisChart(filteredDepositData); // O gráfico ainda usa apenas dados de depósito
        }

        // Renderiza a seção de métricas gerais (Depósitos, Ativações, e Indicações)
        function renderGeneralMetrics(depositData, indicationsOverall) {
            const totalActivations = depositData.filter(item => item['Ativação'] === 'Ativação').length;
            const totalDeposits = depositData.reduce((sum, item) => sum + parseCurrency(item['col_5']), 0);

            DOM.generalMetricsContent.innerHTML = `
                <!-- Card de Métricas de Depósito e Ativação -->
                <div class="fade-in-child bg-black/20 p-6 rounded-3xl h-full border border-transparent" style="animation-delay: 200ms;">
                    <h2 class="text-2xl font-bold text-center text-white">Métricas de Depósito</h2>
                    <div class="mt-4 text-center space-y-4">
                        <div><p class="text-3xl font-black text-blue-400">${formatCurrency(totalDeposits)}</p><p class="text-gray-400 text-sm">Total em Depósitos</p></div>
                        <div><p class="text-3xl font-black text-teal-400">${totalActivations}</p><p class="text-gray-400 text-sm">Total de Ativações</p></div>
                    </div>
                </div>
                <!-- Card de Métricas de Indicações -->
                <div class="fade-in-child bg-black/20 p-6 rounded-3xl h-full border border-transparent" style="animation-delay: 300ms;">
                    <h2 class="text-2xl font-bold text-center text-white">Métricas de Indicações</h2>
                    <div class="mt-4 text-center space-y-4">
                        <div><p class="text-xl font-black text-blue-400">${indicationsOverall.totalIndications}</p><p class="text-gray-400 text-xs">Total de Indicações</p></div>
                        <div class="grid grid-cols-2 gap-4">
                            <div><p class="text-xl font-black text-teal-400">${indicationsOverall.aldeia.total}</p><p class="text-gray-400 text-xs">Indicações Aldeia (Total)</p></div>
                            <div><p class="text-xl font-black text-green-400">${indicationsOverall.aldeia.purchased}</p><p class="text-gray-400 text-xs">Indicações Aldeia (Compradas)</p></div>
                            <div><p class="text-xl font-black text-teal-400">${indicationsOverall.tribo.total}</p><p class="text-gray-400 text-xs">Indicações Tribo (Total)</p></div>
                            <div><p class="text-xl font-black text-green-400">${indicationsOverall.tribo.purchased}</p><p class="text-gray-400 text-xs">Indicações Tribo (Compradas)</p></div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Renderiza um único ranking
        function renderSingleRankingList(title, data, rankingType) {
            let contentHTML = `<div class="min-h-0 flex flex-col fade-in-child w-full">
                <h3 class="text-xl font-bold text-white mb-4 text-center">${title}</h3>`;
            if (data.length === 0) {
                contentHTML += `<div class="bg-black/20 rounded-xl flex-grow flex items-center justify-center"><p class="text-gray-500">Nenhum dado para este ranking.</p></div></div>`;
            } else {
                let listHTML = '<div class="space-y-2 overflow-y-auto flex-grow pr-2 ranking-list">';
                data.forEach((broker, index) => {
                    const rank = index + 1;
                    let valueText;
                    if (rankingType === 'value') {
                        valueText = formatCurrency(broker.totalDeposito);
                    } else if (rankingType === 'activation') {
                        valueText = `${broker.activationCount} Ativações`;
                    } else if (rankingType === 'indications') { 
                        valueText = `${broker.totalIndications} Indicações`;
                    } else {
                        valueText = ''; 
                    }
                    const initials = broker.brokerName.split(' ').map(n => n[0]).join('').substring(0,2).toUpperCase(); 
                    
                    listHTML += `
                        <div class="flex items-center bg-black/20 p-2 rounded-xl transition duration-300">
                            <span class="text-md font-bold text-gray-400 w-8 text-center">${rank}º</span>
                            <div class="w-9 h-9 rounded-full bg-gray-700 flex items-center justify-center font-bold text-sm text-white mx-2 border-2 avatar-ring ${rank <= 3 ? `podium-${rank}`: ''}">
                                ${initials}
                            </div>
                            <span class="font-semibold text-gray-200 flex-1 truncate">${broker.brokerName}</span>
                            <span class="text-sm font-semibold text-gray-300 ml-2 w-32 text-right">${valueText}</span>
                        </div>`;
                });
                listHTML += '</div>';
                contentHTML += listHTML + '</div>';
            }
            return contentHTML;
        }

        // Renderiza a seção do leaderboard, exibindo múltiplos rankings
        function renderLeaderboard(rankings) {
            DOM.leaderboardContent.innerHTML = 
                renderSingleRankingList('DEPÓSITOS', rankings.valueRanking, 'value') +
                renderSingleRankingList('ATIVAÇÕES', rankings.activationRanking, 'activation') +
                renderSingleRankingList('INDICAÇÕES', rankings.indicationsRanking, 'indications'); 
        }

        // Renderiza o gráfico de análise (depósitos por broker)
        function renderAnalysisChart(data) {
            const summary = data.reduce((acc, item) => {
                const brokerName = (item['Broker'] || '').trim(); // Normaliza o nome do broker
                if(!acc[brokerName]) acc[brokerName] = { brokerName: brokerName, totalDeposito: 0, depositoCount: 0 };
                
                const depositoValor = parseCurrency(item['col_5']); 
                if (depositoValor > 0) { 
                    acc[brokerName].totalDeposito += depositoValor; 
                    acc[brokerName].depositoCount++; 
                }
                return acc;
            }, {});
            
            const chartData = Object.values(summary).sort((a,b) => b.totalDeposito - a.totalDeposito).slice(0, 15);

            const existingChart = Chart.getChart('mainChart');
            if (existingChart) {
                existingChart.destroy();
            }

            Chart.defaults.color = '#9ca3af'; 
            mainChartInstance = new Chart('mainChart', {
                type: 'bar',
                data: { 
                    labels: chartData.map(d => d.brokerName), 
                    datasets: [
                        { 
                            label: 'Valor Total Depositado', 
                            data: chartData.map(d => d.totalDeposito), 
                            backgroundColor: 'rgba(56, 189, 248, 0.6)', 
                            yAxisID: 'y' 
                        },
                        { 
                            label: 'Quantidade de Depósitos', 
                            data: chartData.map(d => d.depositoCount), 
                            type: 'line', 
                            borderColor: 'rgba(20, 184, 166, 1)', 
                            tension: 0.3, 
                            yAxisID: 'y1', 
                            pointBackgroundColor: '#06b6d4', 
                            pointRadius: 4 
                        }
                    ]},
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false,
                    scales: { 
                        y: { 
                            type: 'linear', 
                            display: true, 
                            position: 'left', 
                            beginAtZero: true, 
                            grid: { color: 'rgba(55, 65, 81, 0.5)' }, 
                            ticks: { callback: v => formatCurrency(v) }
                        },
                        y1: { 
                            type: 'linear', 
                            display: true, 
                            position: 'right', 
                            beginAtZero: true, 
                            grid: { drawOnChartArea: false }, 
                            ticks: { stepSize: 1, precision: 0 } 
                        }
                    },
                    plugins: { 
                        tooltip: { 
                            backgroundColor: '#1f2937', 
                            callbacks: { 
                                label: c => { 
                                    let l = c.dataset.label || ''; 
                                    if(l) l += ': '; 
                                    if(c.dataset.yAxisID === 'y') l += formatCurrency(c.parsed.y); 
                                    else l += c.parsed.y; 
                                    return l; 
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // --- INICIALIZAÇÃO E CARREGAMENTO DE DADOS ---

        // Função para buscar dados do n8n com retry (exponential backoff)
        async function fetchDataWithRetry(url, retries = 5, delay = 1000) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                if (retries > 0) {
                    await new Promise(res => setTimeout(res, delay));
                    return fetchDataWithRetry(url, retries - 1, delay * 2); 
                } else {
                    console.error(`Falha ao buscar dados de ${url} após múltiplas tentativas:`, error);
                    // Adicionado log de erro específico para o URL que falhou
                    console.error(`Verifique se o webhook "${url}" está ativo no n8n e se o CORS está configurado corretamente.`);
                    return []; // Retorna um array vazio em caso de falha persistente
                }
            }
        }

        // Busca os dados e atualiza o dashboard
        async function fetchDataAndUpdate(initialLoad = false) {
            DOM.loader.textContent = initialLoad ? 'Buscando dados iniciais...' : 'Atualizando dados...';
            DOM.loader.classList.remove('hidden'); 

            try {
                // Busca dados de depósitos
                rawDepositData = await fetchDataWithRetry(DEPOSIT_WEBHOOK_URL);
                // Busca dados de indicações
                rawIndicationsData = await fetchDataWithRetry(INDICATIONS_WEBHOOK_URL);
                
                populateFilters(rawDepositData.concat(rawIndicationsData)); // Popula filtros com base em ambos os datasets
                updateActiveFiltersAndTabs(); 
                renderAll(); 
                
                DOM.loader.classList.add('hidden'); 
                startRotation(); 
                startCountdownTimer(); 
            } catch (error) {
                console.error("Erro ao carregar ou processar dados:", error);
                DOM.loader.textContent = 'Erro ao carregar dados. Verifique o console para detalhes.';
            }
        }

        // Popula dinamicamente os botões de filtro de período
        function populateFilters(data) {
            const months = new Set();
            data.forEach(item => { 
                // Tenta pegar a data de col_6 (depósitos) ou col_1 (indicações)
                const dateString = item['col_6'] || (item['col_1'] ? item['col_1'].split(' ')[0] : null);
                const date = parseDate(dateString); 
                
                if (date && date >= MIN_DATE) { // Apenas adiciona meses a partir da data mínima
                    // Usa a data parseada para formatar o mês/ano
                    const monthYearFormatted = formatMonthYear(date);
                    if (monthYearFormatted) {
                        months.add(JSON.stringify({ value: `${date.getMonth()}_${date.getFullYear()}`, text: monthYearFormatted }));
                    }
                } 
            });
            
            // Ordena os meses do mais recente para o mais antigo
            const sortedMonths = Array.from(months).map(m => JSON.parse(m)).sort((a, b) => { 
                const [am, ay] = a.value.split('_').map(Number); 
                const [bm, by] = b.value.split('_').map(Number); 
                return (by - ay) || (bm - am); 
            });
            
            DOM.filterContainer.innerHTML = `
                <button class="filter-btn px-3 py-1 rounded-md text-sm font-semibold" data-period="all">Geral</button>
                <button class="filter-btn px-3 py-1 rounded-md text-sm font-semibold" data-period="today">Hoje</button>
                <button class="filter-btn px-3 py-1 rounded-md text-sm font-semibold" data-period="this_week">Esta Semana</button>
                ${sortedMonths.map(m => `<button class="filter-btn px-3 py-1 rounded-md text-sm font-semibold" data-period="${m.value}">${m.text}</button>`).join('')}
            `;
            DOM.dotsContainer.innerHTML = views.map((_, i) => `<div class="nav-dot" data-index="${i}"></div>`).join('');

            // Define o filtro inicial para o mês atual (Julho de 2025 ou o mês corrente real)
            const today = new Date();
            const currentMonthValue = `${today.getMonth()}_${today.getFullYear()}`;
            const currentMonthExists = sortedMonths.some(m => m.value === currentMonthValue);
            
            // Se o mês atual existe nos dados filtrados (a partir de MIN_DATE), usa ele. Caso contrário, usa 'all'.
            currentPeriod = currentMonthExists ? currentMonthValue : 'all';
        }

        // Atualiza o estado visual dos botões de filtro
        function updateActiveFiltersAndTabs() {
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.toggle('filter-btn-active', btn.dataset.period === currentPeriod));
        }
        
        // Inicia o contador regressivo para a próxima atualização de dados
        function startCountdownTimer() {
            clearInterval(countdownIntervalId); 
            let timeLeft = DATA_REFRESH_INTERVAL / 1000; 
            DOM.countdownTimer.textContent = `Atualiza em ${formatTime(timeLeft)}`;

            countdownIntervalId = setInterval(() => {
                timeLeft--;
                if (timeLeft <= 0) {
                    clearInterval(countdownIntervalId);
                    DOM.countdownTimer.textContent = 'Atualizando...';
                } else {
                    DOM.countdownTimer.textContent = `Atualiza em ${formatTime(timeLeft)}`;
                }
            }, 1000);
        }

        // Formata o tempo em minutos e segundos
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // Configura todos os event listeners
        function setupEventListeners() {
            // Event listener para os botões de filtro de período
            DOM.filterContainer.addEventListener('click', e => { 
                if (e.target.matches('.filter-btn')) { 
                    currentPeriod = e.target.dataset.period; 
                    updateActiveFiltersAndTabs(); 
                    renderAll(); 
                    showView(currentViewIndex, true); 
                } 
            });

            // Event listener para os pontos de navegação dos slides
            DOM.dotsContainer.addEventListener('click', e => { 
                if (e.target.matches('.nav-dot')) { 
                    showView(parseInt(e.target.dataset.index), true); 
                } 
            });

            // Event listeners para os botões de navegação de slide
            DOM.prevBtn.addEventListener('click', () => prevView());
            DOM.nextBtn.addEventListener('click', () => nextView(true));

            // Event listener para o botão de atualização manual
            DOM.refreshBtn.addEventListener('click', () => {
                clearTimeout(rotationTimeoutId);
                cancelAnimationFrame(animationFrameId);
                clearInterval(countdownIntervalId);
                fetchDataAndUpdate(false);
            });

            // Pausar/Retomar rotação ao passar o mouse sobre o centro de comando
            DOM.commandCenter.addEventListener('mouseenter', pauseRotation);
            DOM.commandCenter.addEventListener('mouseleave', resumeRotation);
        }

        // Função de inicialização principal
        function initialize() {
            setupEventListeners(); 
            fetchDataAndUpdate(true); 
        }

        // Inicia a aplicação quando a janela estiver totalmente carregada
        window.onload = initialize;
    })();
    </script>
</body>
</html>
